	package infa;
	public class primitives_operand {}
	
//	Большинство операций над примитивными типами выполняется не с помощью методов, а с помощью специальных символов, называемых знаком операции.
	
	
	//    2.1.8.1. Операция присваивания
	/**
	Присвоение переменной значения константы, другой переменной или выражения (переменных и/или констант, разделенных знаками операций), называется операцией присваивания и обозначается знаком "=", например:
	x = 3; y = x; z = x;
	В Java допустимо многократное использование операции присваивания в одном выражении, например:
	x1 = x2 = x3 = 0;
	Эта операция выполняется справа налево, т.е. сначала переменной x3 присваивается значение 0, затем переменной x2 присваивается значение переменной x3 (0), и, 
	наконец, переменной x1 присваивается значение переменной x2 (0).
	Знаки операций, аргументами которых являются числа, разделяются на две категории: унарные (unary) знаки операций с одним аргументом и бинарные (binary) с двумя аргументами.
	*/
	
	//    2.1.8.2. Унарные операции
	/**
	В Java определены следующие унарные операции:
	· унарный минус "-" – меняет знак числа или выражения на противоположный;
	· унарный плюс "+" – не выполняет никаких действий над числом или выражением;
	· побитовое дополнение "~" (только для целых) – инвертирует все биты поля числа (меняет 0 на 1 и 1 на 0);
	· инкремент "++" (только для целых) – увеличивает значение переменной на 1;
	· декремент "--" (только для целых) – уменьшает значение переменной на 1.
	Примеры унарных операций "+" и "-":
	int i = 3, j, k;
	j= -i; // j = -3
	k = +i; // k = 3
	Пример операции побитового дополнения:
	int a = 15;
	int b;
	b = ~a; // b = -16
	Числа a и b являются числами типа int, т.е. представляются внутри компьютера как двоичные целые числа со знаком длиной 32 бита, 
	поэтому двоичное представление чисел a и b будет выглядеть следующим образом:
	a = 00000000 00000000 00000000 00001111
	b = 11111111 11111111 11111111 11110000
	Как видно из этого представления, все нулевые биты в числе a изменены на единичные биты в числе b, а единичные биты в a изменены на нулевые биты. Десятичным представлением числа b будет –16.
	Знаки операции инкремента и декремента могут размещаться как до, так и после переменной. Эти варианты называются соответственно префиксной и постфиксной записью этих операции. 
	Знак операции в префиксной записи возвращает значение своего операнда после вычисления выражения. 
	При постфиксной записи знак операции сначала воз­вращает значение своего операнда и только после этого вычисляет инкремент или декремент, например:
	int x = 1, y, z;
	y = ++x;
	z=x++;
	Переменная y будет присвоено значение 2, поскольку сначала значение x будет увеличено на 1, а затем результат будет присвоен переменной y. Переменной z будет присвоено значение 1,
	поскольку сначала переменной z будет присвоено значение, а затем значение x будет увеличено на 1. В обоих случаях новое значение переменной x будет равно 2.
	Следует отметить, что в Java, в отличие от языка C, операции декремента и инкремента могут применяться и к вещественным переменным (типа float и double).
	Бинарные знаки операций подразделяются на операции с числовым результатом и операции сравнения, результатом которых является булевское значение.
	*/
	
	//   2.1.8.3. Арифметические бинарные операции
	/**
    В Java определены следующие арифметические бинарные операции:
	· сложение "+";
	· вычитание "-";
	· умножение "*";
	· деление "/";
	· вычисление остатка от деления целых чисел "%" (возвращает остаток от деления первого числа на второе, причем результат будет иметь тот же знак, что и делимое), 
	например, результат операции 5%3 будет равен 2,
	а результат операции (-7)%(-4) будет равен -3. В Java операция может использоваться и для вещественных переменных (типа float или double).
	Примеры бинарных арифметических операций:
	
	int x = 7, x1, x2, x3, x4, x5;
	
	x1 = x +10; // x1 = 17
	
	x2 = x – 8; // x2 = -1
	
	x3 = x2 * x; // x3 = -7
	
	x4 = x/4; // x4 = 1 (при делении целых чисел дробная часть отбрасывается)
	
	x5 = x%4 // x5 = 3 (остаток от деления 7 на 4)
	*/
	
	
	//     2.1.8.4. Побитовые операции
	/**
	Побитовые операции рассматривают исходные числовые значения как поля битов и выполняют над ними следующие действия:
	· установка бита в i-ой позиции поля результата в 1, если оба бита в i-ых позициях операндов равны 1, или в 0 в противном случае – побитовое И ("&");
	· установка бита в i-ой позиции поля результата в 1, если хотя бы один бит в i-ых позициях операндов равен 1, или в 0 в противном случае – побитовое ИЛИ ("|");
	· установка бита в i-ой позиции поля результата в 1, если биты в i-ых позициях операндов не равны друг другу, или в 0 в противном случае – побитовое исключающее ИЛИ ("^");
	· сдвиг влево битов поля первого операнда на количество битов, определяемое вторым операндом (бит знака числа при этом не меняется) – побитовый сдвиг влево с учетом знака "<<";
	· сдвиг вправо битов поля первого операнда на количество битов, определяемое вторым операндом (бит знака числа при этом не меняется) – побитовый сдвиг вправо с учетом знака ">>";
	· сдвиг вправо битов поля первого операнда на количество битов, определяемое вторым операндом (бит знака числа при этом также сдвигается) – побитовый сдвиг вправо без учета знака ">>>".
	Примеры побитовых операций:
	
	1. Побитовое И
	int x = 112;
	// x: 00000000 00000000 00000000 01110000
	int y = 94;
	// y: 00000000 00000000 00000000 01011110
	int z;
	z = x & y;
	// z=80: 00000000 00000000 00000000 01010000 
	
	2. Побитовое ИЛИ
	int x = 112;
	// x: 00000000 00000000 00000000 01110000
	int y = 94;
	// y: 00000000 00000000 00000000 01011110
	int z;
	z =x | y;
	// z = 126: 00000000 00000000 00000000 01111110
	
	3. Побитовое исключающее ИЛИ
	int x = 112;
	// x: 00000000 00000000 00000000 01110000
	int y = 94;
	// y: 00000000 00000000 00000000 01011110
	int z;
	z =x ^ y;
	// z = 46: 00000000 00000000 00000000 00101110
	
	4. Сдвиг влево с учетом знака
	int x = 31, z;
	// x: 00000000 00000000 00000000 00011111
	z = x << 2;
	// z = 124: 00000000 00000000 00000000 01111100
	 
	5. Сдвиг вправо с учетом знака
	int x = -17, z;
	// x: 11111111 11111111 11111111 11101111
	z = x >> 2;
	// z = -5: 11111111 11111111 11111111 11111011
	 
	6. Сдвиг вправо без учета знака
	int x = -17, z;
	// x: 11111111 11111111 11111111 11101111
	z = x >>> 2;
	// z = 1073741819
	// z: 00111111 11111111 11111111 11111011
	 */
	
	Побитовые сдвиги

	Чтобы окончательно покрыть тему о битовых операциях, вспомним также о сдвигах. В x86 ассемблере есть целая пачка различных команд, 
	которые делают побитовые сдвиги — SHL, SHR, SAL, SAR, ROR, ROL, RCR, RCL. Последние 4 осуществляют циклические сдвиги, их эквивалентов в Java нет. 
	А вот логические и арифметические сдвиги присутствуют. Логический сдвиг (не учитывает знака) — SHL (shift left) и SHR (shift right) — реализуется в Java операторами << и >>> соответственно. 
	С помощью логических сдвигов можно быстро выполнять целочисленные умножение и деление на числа степени двойки. Арифметический сдвиг (учитывает знак) вправо — SAR — реализуется оператором >>. 
	Арифметический сдвиг влево эквивалентен логическому, и поэтому специального оператора для него нет. Может показаться странным, что в ассемблере есть специальный опкод для этой операции, 
	но на самом деле он делает то же самое, то есть SAL полностью повторяет поведение SHL, и об этом прямо говорит документация от Intel:
	----->	
	The shift arithmetic left (SAL) and shift logical left (SHL) instructions perform the same operation; they shift the bits in the destination operand to the left (toward more significant bit locations). 
	For each shift count, the most significant bit of the destination operand is shifted into the CF flag, 
	and the least significant bit is cleared (see Figure 7-7 in the Intel®64 and IA-32 Architectures Software Developer'sManual, Volume 1).
	<------
	То есть SAL добавили просто для симметрии, с учётом того, что для сдвига вправо есть разделение на логический и арифметический. Ну а Гослинг решил не заморачиваться (и, думается, правильно сделал).

	Итак, мы имеем следующее:

	a << 1; // беззнаковый сдвиг влево, эквивалентно умножению на 2
	a >> 1; // сдвиг вправо с учётом знака (эквивалентно делению на 2)
	a >>> 1; // сдвиг вправо без учёта знака (эквивалентно беззнаковому делению на 2)
	
	 Заключительные рекомендации

	При выполнении арифметических действий, которые могут привести к переполнению в выбранной разрядной сетке, нужно всегда точно представлять, 
	какая область допустимых значений может быть у переменных, и отслеживать эти инварианты, расставляя утверждения (assertions). 
	Например, очевидно, что при умножении двух произвольных 32-разрядных беззнаковых чисел результат может не поместиться в 32 бита, и если вам нужно избежать переполнения, 
	нужно либо убедиться, что в этом месте никогда не будет ситуации, при которой произведение не влезает в 32 бита, 
	либо необходимо предварительно сконвертировать оба операнда в long (выполнив a & 0xffffffffL). Здесь, кстати, можно легко допустить ошибку, сконвертировав только один из операндов. 
	Нет, нужно сконвертировать в long оба, т.к. если второй операнд окажется отрицательным, он будет неявно преобразован в long с расширением знака, и результат умножения будет неправильным.
	Щедро расставляйте скобки в выражениях, где используются побитовые операции. Дело в том, что приоритет побитовых операторов в Java несколько странный, и часто ведёт себя неочевидным образом. 
	Лучше добавить пару скобок, чем потом несколько часов искать трудноуловимые ошибки.
	Если вам нужна константа типа long, не забудьте добавить суффикс L в конец литерала константы. 
	Если этого не сделать, это будет не long, а int, и при неявном приведении к long снова произойдёт неприятное нам расширение со знаком.
		
	//     2.1.8.5. Комбинированные операции
	/**
	В Java для бинарных арифметических операций можно использовать комбинированные (составные) знаки операций:
	идентификатор операция = выражение
	Это эквивалентно следующей операции:
	идентификатор = идентификатор операция выражение
	
	Примеры:
	1. Выражение x += b означает x = x + b.
	2. Выражение x -= b означает x = x - b.
	3. Выражение x *= b означает x = x * b.
	4. Выражение x /= b означает x = x / b.
	5. Выражение x %= b означает x = x % b.
	6. Выражение x &= b означает x = x & b.
	7. Выражение x |= b означает x = x | b.
	8. Выражение x ^= b означает x = x ^ b.
	9. Выражение x <<= b означает x = x << b.
	10. Выражение x >>= b означает x = x >> b.
	11. Выражение x >>>= b означает x = x >>> b.
	*/
	
	
	//        2.1.8.6. Операции сравнения
	/**
	В Java определены следующие операции сравнения
	"==" (равно), "!=" (не равно),
	">" (больше), ">=" (больше или равно),
	"<" (меньше) "<=" (меньше или равно)
	имеют два операнда и возвращают булевское значение, соответствующее результату сравнения (false или true). Следует обратить внимание, 
	что при сравнении двух величин на равенство в Java, как и в C и в C++, 
	используются символы "==" (два идущих без пробела друг за другом знака равенства), в отличие от оператора присваивания, 
	в котором используется символ "=". Использование символа "=" при сравнении двух величин либо вызывает ошибку при компиляции, либо приводит к неверному результату.
	 
	Примеры операций сравнения:
	boolean isEqual, isNonEqual, isGreater,
	isGreaterOrEqual, isLess, isLessOrEqual;
	int x1 = 5, x2 = 5, x3 = 3, x4 = 7;
	isEqual = x1 == x2; // isEqual = true
	isNonEqual = x1 != x2; // isNonEqual = false
	isGreater = x1 > x3; // isGreater = true
	// isGreaterOrEqual = true
	isGreaterOrEqual = x2 >= x3;
	isLess = x3 < x1; // isLess = true
	isLessOrEqual = x1 <= x3; // isLessOrEqual = false
	*/
	
	
	//     2.1.8.7. Булевские операции
	/**
	Булевские операции выполняются над булевскими переменными и их результатом также является значение типа boolean. В Java определены следующие булевские операции:
	· отрицание "!" – замена false на true, или наоборот;
	· операция И "&" – результат равен true, только, если оба операнда равны true, иначе результат – false;
	· операция ИЛИ "|" – результат равен true, только, если хотя бы один из операндов равен true, иначе результат – false.
	· операция исключающее ИЛИ "^" – результат равен true, только, если операнды не равны друг другу, иначе результат – false.
	Операции "&", "|" и "^" можно, также как и соответствующие побитовые операции использовать в составных операциях присваивания: "&=", "|=" и "^="
	Кроме того, к булевским операндам применимы операции "==" (равно) и "!=" (не равно).
	Как видно из определения операций ИЛИ и И, операция ИЛИ приводит к результату true, когда первый операнд равен true, незави­симо от значения второго операнда, 
	а операция И приводит к результату false,
	 когда первый операнд равен false, независимо от значения второго операнда.
	В Java определены еще две булевские операции: вторые версии булевских операций И и ИЛИ, 
	известные как укороченные (short-circuit) логические операции: укороченное И "&&" и укороченное ИЛИ "||".
	При использовании этих операций второй операнд вообще не будет вычисляться, что полезно в тех случаях, 
	когда правильное функционирование правого операнда зависит от того, 
	имеет ли левый операнд значение true или false.
	 
	Примеры булевских операций:
	boolean isInRange, isValid, isNotValid,
	isEqual, isNotEqual;
	int x = 8;
	isInRange = x > 0 && x < 5; // isInRange = false
	isValid = x > 0 || x > 5; // isValid = true
	isNotValid = !isValid; // isNotValid = false
	isEqual = isInRange == isValid; // isEqual = false
	// isNotEqual = true
	isNotEqual = isInRange != isValid
	 */
	
	
	//     2.1.8.8. Условная операция
	/**
	Условная операция записывается в форме
	выражение-1?выражение-2:выражение-3.
	При этом сначала вычисляется выражение выражение-1, которое должно дать булевское значение, а затем, если выражение-1 имеет значение true, 
	вычисляется и возвращается выражение-2 как результат выполнения операции, 
	либо (если выражение-1 имеет значение false), вычисляется и, как результат выполнения операции, возвращается выражение-3.
	 
	 
	Пример условной операции:
	x=n>1?0:1;
	Переменной x будет присвоено значение 0, если n>1 (выражение n>1 имеет значение true) или 1, если n≤1 (выражение n>1 имеет значение false).
	*/
	
	
	//     2.1.8.9. Старшинство операций
	/**
	Операции в выражениях выполняются слева направо, однако, в соответствии со своим приоритетом. Так операции умножения в выражении
	y = x +z*5;
	будет выполнена раньше, чем операция сложения, поскольку приоритет операции умножения выше, чем приоритет операции сложения.
	Приоритеты операций (в порядке уменьшения приоритета) в Java приведены в табл. 2.1.4.
	 
	Табл. 2.1.4. Приоритеты операций в Java
	Операция                Описание
	
	() [ ]                  Круглые и квадратные скобки
	
	++ -- + - ~ !           Декремент, инкремент, унарный плюс, унарный минус, поразрядное отрицание, логическое отрицание
	
	* / %                   Умножение, деление, деление нацело
	* 
	+ -                     Сложение, вычитание
	
	>> >>> <<               Побитовый сдвиг вправо, побитовый сдвиг вправо с заполнением старшего бита нулем, побитовый сдвиг влево
	
	> >= < <=               Сравнение на больше, больше или равно, меньше, меньше или равно
	
	== !=                   Сравнение на равенство, сравнение на неравенство
	
	&                       Поразрядное и логическое И
	
	^                       Поразрядное и логическое исключающее ИЛИ
	
	|                       Поразрядное и логическое ИЛИ
	
	&&                      Логическое укороченное И
	
	||                      Логическое укороченное ИЛИ
	
	? :                     Условная операция
	
	=op                     Комбинированные операции (op – одна из арифметических или побитовых операций)
	
	Круглые скобки повышают старшинство операций, которые находятся внутри них. Так, если в приведенное выше выражение вставить скобки:
	y = (x +z)*5;
	то сначала будет выполнена операция сложения, а затем операция умножения.
	Иногда скобки используют просто для того, чтобы сделать выражение более читаемым, например:
	(x > 1) && (x <= 5).
	*/
	
	
	//   2.1.8.10. Преобразование и приведение типов при выполнении операций
	/**
	В операции присваивания и арифметических выражениях могут использоваться литералы, переменные и выражения разных типов, например:
	double y;
	byte x;
	y = x + 5;
	В этом примере выполняется операция сложения переменной x типа byte и литерала 5 (типа int) и результат присваивается переменной y типа double.
	В Java, как и в языке C, преобразования типов при вычислении выражений могут выполняться автоматически, либо с помощью оператора приведения типа. 
	Однако правила приведения типов несколько отличаются от правил языка C,
	и в целом являются более строгими, чем в языке C.
	При выполнении операции присваивания преобразование типов происходит автоматически, если происходит расширяющее преобразование (widening conversion) и два типа совместимы.
	Расширяющими преобразованиями являются преобразования byte®short®int®long®float®double.
	Для расширяющих преобразований числовые типы, включая целый и с пла­вающей точкой, являются совместимыми друг с другом. Однако числовые типы не совместимы с типами char и boolean. 
	Типы char и boolean не совмес­тимы также и друг с другом.
	В языке Java выполняется автоматическое преобразование типов также и при сохранении литеральной целочисленной константы (которая имеет по умолчанию тип int) в перемен­ных типа byte, 
	short или long (однако если литерал имеет значение вне диапазона допустимых значений для данного типа, выдается сообщение об ошибке: возможная потеря точности).
	Если преобразование является сужающим (narrowing conversion), т. е. выполняется преобразование byte¬short¬char¬int¬long¬float¬double, 
	то такое преобразование может привести к потере точности числа или к его искажению. 
	Поэтому при сужающих преобразованиях при компиляции программы выводится диагностическое сообщение о несовместимости типов и файлы классов не создаются. 
	Такое сообщение будет выдано и при попытке преобразование выражений типа byte или short в переменную типа char.
	Если все же необходимо выполнить такие преобразования, используется операция приведения (cast) типа, которая имеет следующий формат:
	(тип-преобразования) значение
	где тип-преобразования определяет тип, в который необходимо преобразовать заданное значение, например, в результате выполнения операторов:
	byte x = 71;
	char symbol = (char) x;
	переменная symbol получит значение 'G'.
	Если значение с плавающей точкой присваивается целому типу, то (если значение с плавающей точкой имеет дробную часть) при явном преобразовании типа происходит также усечение (truncation) числа. 
	Так, в результате выполнения оператора
	int x = (int) 77.85;
	переменная x получит значение 77. Если же присваиваемое значение лежит вне диапазона типа-преобразования,
	то результатом преобразования будет остаток от деления значения 
	на модуль диапазона присваиваемого типа (для чисел типа byte модуль диапазона будет равен 256, для short – 65536, для int – 4294967296 и для long – 18446744073709551616). 
	Например, в результате выполнения оператора
	byte x = (byte) 514;
	переменная x получит значение 2.
	При преобразовании целых или вещественных чисел в данные типа char, преобразование в символ происходит, если исходное число лежит в диапазоне от 0 до 127, иначе символ получает значение '?'.
	При выполнении арифметических и побитовых преобразований все значения byte и short, а также char расширяются до int, (при этом в вычислениях для char используется числовое значение кода символа) затем,
	если хотя бы один операнд имеет тип long, тип целого выражения расширяется до long. Если один из операндов имеет тип float, то тип полного вы­ражения расширяется до float, 
	а если один из операндов имеет тип double,
	то тип результата будет double. Так, если объявлены переменные
	byte a, c;
	short b;
	то в выражении
	a + b*c – 15L + 1.5F + 1.08 - 10;
	сначала, перед вычислением a + b*c значения переменных будут расширены до int, затем, поскольку константа 15 имеет тип long, перед вычитанием результат вычисления будет увеличен до long.
	После этого, поскольку литерал 1.5 имеет тип float перед сложением с этим литералом результат вычисления a + b*c – 15L будет расширен до float. 
	Перед выполнением сложения с числом 1.08 результат предыдущих вычислений будет расширен до double (поскольку вещественные константы по умолчанию имеют тип double) и, 
	наконец, перед выполнением последнего сложения литерал 10 (по умолчанию int) будет расширен до double. Таким образом, результат вычисления выражения будет иметь тип double.
	Автоматические расширения типов (особенно расширения short и byte до int) могут вызывать плохо распознаваемые ошибки во время компиляции. Например, в операторах:
	byte x = 30, y =5;
	x = x + y;
	перед выполнением умножения значение переменных x и y будет расширено до int, а затем при выполнении попытки присвоения результата вычисления типа int переменной типа byte будет выдано сообщение об ошибке.
	Чтобы этого избежать надо использовать во втором операторе явное преобразование типов:
	x = (byte) (x + y);
	Выражение x + y необходимо заключит в скобки потому, что приоритет операции приведения типа, заключенной в скобки, выше, чем приоритет операции сложения. Кстати, если записать второй оператор в виде:
	x += y;
	то сообщения об ошибке не будет.
	**/